Hey, y'all. I'm Austin Vance, CEO, cofounder of Focus Labs. I wanted to dive into part two of this PDF RAG, tutorial. So in the tutorial, kind of through all the parts, we will build a full production ready, AI chatbot that uses, retrieval to go and search court documents. It can scan those court documents, chunk them out and then give the AI bot a way to to use them. Then we will have, you know, build out a front end and then finally deploy that to production. And we will also do things like add in, chat history and give ourselves some different ways of searching so we can see how, you know, when we do similarity searches or build in questions or multi questions, we can get totally different results or better results and ways to play with them. When we deploy, we'll deploy both to DigitalOcean as well as LangServe. So you can see the difference in how you would do that. And then you'll end up with a fully scaled functioning, you know, RAG using PG vector deployed for production that is ready to go with the front end. There's, of course, more you can do, but this is it. So when I when I do this, I can I I actually already recorded this video once and it ended up being really long and really difficult to follow? So I'm gonna make it a little more linear, but, because of that, it won't reflect the actual nature of how you develop, an application. Instead, we'll kind of work our way from the back end to the front end and sort of kind of hopping between the two. This will make it really easy, hopefully, to follow along. But if you're hacking away yourself, I would think you would iterate a little bit more between the back end end and the front end rather than kind of completing a back end and then, you know, building the front end directly on top of that, knowing exactly what your front end needs. So I hope that's okay. If you guys want something a little more raw, maybe I do a live stream or or something like that. But I I wanted the video to be easy to follow, and easy to reproduce. As always, I will put all the code up on GitHub as well so you can take the code, follow along, check out the final examples. I'll try to make as many incremental commits as I can remember to. So you have something to kind of refer to along the way, and, that should give you everything you need. So I don't know. Let's dive in. So the first kind of part of any first part of our RAG is we wanna get our back end ready. So if we go to our server and maybe I remind you kind of where part one left us is we have a server. This is a lang a lang serve server. And so what lang serve does is it just makes it super easy to drop in a runnable from lang chain. So any LCEL runnable or an an agent graph or anything like that can get dropped in, and you can just, you know, give it a path and lang serve knows how to serve it out of fast API. And it's great. Makes it super easy. It comes with a Dockerfile. Gets you up and running in a really a production ready way in no time. And then inside of our app, if you remember in our we have an importer as well. The importer takes in all of our source documents. Those are hiding here, reads them with unstructured, loads them, embed you know, and then chunks them. And then finally, we split up those, documents and store them in Postgres, which is great. And then finally, we have our, rag. And so our rag was a really simple, you know, l c e l or LaSalle chain. So we just have a standard, rag prompt. We grab or we we are able to then search our vector store, you know, as a retriever based on the question getting asked, and we pull that out and we, you know, feed that into our prompt, let the LLM then look at that prompt with our question, and then finally parse it for output. This with types, I had a couple of questions about. So, Langserve really likes or needs to have, pedantic signatures or, like, type inference. And because of the way this chain is built, it couldn't infer, you know, what inputs the type need or the chain needs in order to use the Langserve playground. And so what we can do is we create a a type that then allows Langserve to to infer exactly what types should be there. So first things first, actually, what I wanna do is I just wanna start this so we can look at it. So if I start this, maybe let's start it with lang serve. Langstream serve. So this will run it just as we would expect. We'll get reload, and let's pop in right here. So we go to local host, 8,000, just like last time. You can see we have our our docs and everything. And what I wanna look at is actually if we go to our stream endpoint and we send a questions like what is the case about? We end up with and we'll let this load for a second. It takes a second to come back because, these docs, the fast API generated docs don't actually stream the output for us. It'll come back in just a second and you'll see what happens is rather than streaming the output, we're gonna stream just the LLM tokens. And so that's really nice. And you'll see here, like, we get a run ID and then we just get straight up strings. The case mentioned in the provided context appears to be dot dot dot. So that's fine for maybe a command line application or if we had a specific endpoint, we want to send that down. But I actually also want source material to get sent down to my front end, along with, some other metadata. And when I say source material, I mean, if we go and look at the actual intermediate steps that are happening here, and we can do that in the playground. If we go and look at that in the playground and we say, what is the case about? Even though we're streaming those this these tokens as you would kind of expect, we have these intermediate steps where we're getting documents. And if you notice those documents point to a path on my computer that the document was sourced from, which is great because then what we can do is we can display sources on the front end, which I think is really important for a RAG. You can kinda click into the part of the application and see, you know, did the LLM hallucinate or is it, actually a source? And and you have actually even like, you know, you know, you have the page content too. This page content is pretty small. So and then you have the metadata. So what we need to do is take a look at our final chain here and edit this so we get a better output for our front end before we dive in. So there's kind of two parts if you remember on this final chain. There is, our input comes in, which is a question. Our question gets, you know, passed into our vector store as a your vector store or our retriever and gets retrieved out, and then all of that data comes as context and is put into our prompt under context. And then the question also is passed in just as question to our answer prompt, and is passed in here. Then that answer this whole thing is then pushed out to our LLM. In this case, it's, GPT four, you know, preview, the the not latest and greatest GPT four, but the, one that was out when I did part one. And then we pass that into a string output parser. So the first thing that we wanna do is remove that string output parser. That gives us a really nice if we just look at how that changes our output here, we can send again, our thing and if you notice, doesn't change a ton, but it will on the front end. The other thing we need to do, and I've actually started to become preferable on being a little more explicit, is using runnable parallels instead of, the dictionary syntax for, parallel runnables. So the syntax is pretty simple, it looks just like this, to convert them and this is this is functionally equivalent to what we had before. It just makes it a little easier for me to read and sometimes Python has a hard time. So now it's exactly the same. We do exactly what we had before. We're not parsing to the string output parser, But now what we actually wanna do is we wanna get this context, which are all those documents, and we wanna send those into the front end as well. And so what the LLM is giving us back is an answer, you know, an answer to our question. But then we also wanna get whatever this, vector store, has returned back to us. So to do that, I'm actually gonna create another runnable parallel. I'm gonna create another runnable parallel. I'm gonna just put that down here for now. And if we look at what we want here, this is our first kind of chain. And like I said, that's the answer that we want. So if I say answer equals this and then I go here, I can also then say I wanna get these documents. So I wanna just say docs maybe, or I could say contacts or whatever I want. Docs equal, you know, context, or item getter, context. And there's two ways you saw it was recommending something. There's another way you can do that, which is using a Lambda Lambda x, you know, and then you can get out of the context stuff. It's not a lot like that. You would just return x context. But I I actually think this is a cleaner, more easy to read way of getting that data back. So now we take kind of our our runnable. We pass our question in. We give that to the LLM, and then we pass our prompt on. There's another you could you could compact this in by, you know, putting this in here and then having it just be one and the context could come out. There's a handful of ways to do that. I think this is really clean as it represents two clear steps in my chain, and I could even grab this, variableize it and print it out, debug it, whatever I needed to do. So if we pop back into our playground again, I'll make this text a little bit bigger, and I say, what is the case about? And I run this. We'll notice now instead we get JSON output, and that's the literally the output of this runnable parallel is a is a dictionary of with the keys answer and docs if they exist. And so if we look here, what we get is we get, you know, documents and then we get all of our documents. And then following that, we get, you know, answer content, the case mentioned in the context, which is great. So now we have something we can start to work with on the front end. So that actually, will do most of what we need on the front end. The only other thing we need to do, and we can error drive this if we wanted to is actually let's error drive it. So when I say error drive, I mean let's get to the point where we see this error and then fix it. So our rag chain feels really good, our server feels really good, at least for now, And so let's start thinking about how we want our front end to feel. So our front end, we want just like a standard chat application. I think I'll just use Tailwind and, React, create React app. It's maybe a little heavy for something, and I'm gonna just work inside of one component. So it's a little less confusing to watch. I would likely split this out into a handful of components and share state between them. If I were building this, you know, truly for maintainability production and to go to scale, with a team, but for now with just me working here, I'm going to just, you know, work off of, one one component literally. So if I do a create React app, which is my first thing I need to do, I'm gonna create, you know, inside of my base directory here, React app with TypeScript. So I just do create React app and that'll run. And then while that runs, or we'll let that finish, and then we'll pop in and we'll install a few more dependencies that are important to remember. And so one of the things that happens here and and you just kinda need to know is what lang serve does is it serves all this data back down through a service and event when you use the stream endpoint. And that's great because what you can do is you get that, like, that streaming feel. Right? And you don't have to you don't have to necessarily long pull. Service and events are essentially polling, but you don't have to necessarily do that. The problem is the native event source, native event source class inside of the browser isn't designed to handle, you know, posting data up. It's really just designed for listening. So we're gonna need to use another dependency in order to do that. Microsoft makes something. It's called fetch event source. And so what we wanna do is install our fetch event source, and that'll come in and then we wanna install Tailwind. So those three things give us everything we need for the front end and then we just need to init Tailwind. So that'll give us a tailwind config inside of our front end. So now you see we have a front end, package sitting at the root. We have our tailwind config sitting here and we're ready to go. So if you're not familiar with the create react app, it's probably not a good place. This is probably not a good place for you to start. I'm gonna just clean up a couple of things because they're not that necessary, but if I go npm start now, I end up with, let's see. Boom. Our basic create react app. It's not using Tailwind or anything yet, but it's close. So first things first, in order to use Tailwind, there's one last bit of kind of boilerplate we need, which is we need to make sure that we get the right sources. And so to do that, we just kinda paste in something or even if you look at that, it's, like, pretty close, not really that close. Copilot was suggesting something. We just need to paste in that we want our Tailwind to look inside of our source directory for any JS, JSX, TypeScript, or TSX files, in order to add Tailwind styles. So that'll be pretty simple. Although we're not using it yet, that'll give us the the beginnings of what we need. And then everything else we're gonna do, we're gonna work out of this app TSX. So one thing that I kind of played with in the first take of this, I guess, was how to structure this. And so I think what I'm gonna do is I'm gonna build out kind of a basic structure, but not add a lot of behavior so we can see what it looks like to build. And then we'll start adding behavior, but I think it got a little confusing because I was adding kind of way too much scaffolding early. So, for our first kind of wrapper and if I save this already, you'll notice like it auto updates, everything's great. Let me know if these key bindings are helpful for you all and we'll go from there. So I really what I wanna do is I wanna have, you know, our min height of our entire application to be, you know, the screen. So we just want it to fill up the screen and then we can say, you know, BG gray. We'll make it, you know, gray, a dark kind of deep gray, like a chat GPT dark mode. And then, yeah, something really basic here. And I would have expected something to show up in there or that to actually turn gray. Let's keep going and see why that didn't go. Let's give ourselves a header and our header we can name it like epic b apple legal assistant and notice. Oh, because the tailwind config, I need to restart this. Now it'll load with everything. Give it a second here. Tailwindconfig dot slash source, JS JSX. And if I go to our app TSX here oh, duh. One more thing we have to do for Tailwind, which is always something I forget, is import the main Tailwind kind of helpers. So in our index index CSS, you know, all this stuff doesn't really matter because Tailwind will handle this for us, is just paste in, and this is all in, like, the Tailwind setup docs too, is paste in the base component setup. So now we're feeling good. You can't see the text, but it's right there, Epic v Apple legal assistant, and we have everything we need. So let's keep going. So if we go into our, you know, our front end and we look at kind of this header, we'll start giving ourselves some real, classes. So it's, like, give this one, you know, maybe b g gray 800 a little lighter and make the text white. And, we'll center our text and maybe pat it out a little bit. And that feels good. It was still highlighted, but now we have a nice little header, and then we can drop a footer down here or we'll do a main and then we can drop a footer down here. And in our footer, let's say maybe we want that to be similar to our, our header. We'll say, you know, something along the lines of b g gray hundred. The text should be white again. The text should be centered, and we'll pad that out again for as well. And then we can have, you know, just some basic I'm gonna just paste in some stuff for our footer. I think it'll give some some depth to the content. And, you can see it's you know, nothing's in our main filling up the space yet, so they're just kinda tacked to each other. And so oh, well. We'll fix that in just a second. And there we go. So kind of paste all that in. We have a little bit of content here. I'd make this text small. It seems a little big. Text size text, maybe small. Extra small. Yeah. That looks good. Cool. So now let's work on our main, content. So this is where all the the magic will happen or the chat. So class name is gonna be, flex grow. We want it to fill the whole space that will already push down our, footer. So now we have kind of our main content area. Where'd my mouse go? There it is. Cool. We have our main content area here. And as you saw, then we can start to work kind of around that. So in our main, let's make it a container, and we'll say, you know, margins are on the left and right. Our auto will pad them out by four and we'll give make it a column or we'll make it kind of flow like a column. This doesn't create any visual changes, but it does set up what we need kind of on the inside of this. So inside of this, we're gonna create some wrappers. Wow. Sometimes, Copilot really adjusts some aggressive stuff. And if I hit tab, it'll fill all that in, which is more than I need. So I wanna do another flex grow here. Flex grow, and, we'll make this one, like, b g gray, maybe 700, a little lighter, and we'll give it a shadow. And it's completing some so completing some stuff for us because I've already typed this out a couple of times. But we're giving it a shadow, and then we're gonna make the overflow scroll, and we will, gonna round out the sides, which doesn't really matter, because this is, like, kind of a a large container that we don't really see. And then we wanna contain our messages in something. So if we think like this here is gonna be, you know, ID is gonna be, like, all of our con kind of containers, and then here we have messages. If last name equals, and then we'll say maybe, like, border bottom, and so this will kind of be the between messages, or not quite, but border gray and we'll pad that out, and that should go like that. So now we have kind of in here will be messages. And then we need a place to put our, we need a place to put our, whoops. Sorry. I'm looking at my notes on the side here. Give me one second. We need a place to put our text area. So our text area will go kind of just below this. So this is gonna kind of be all of the the stuff that contains, yeah, this will be all the stuff that contains, like, the chat input. But for our chat input, we wanna say maybe, like, a div again and then class name is gonna be, let's see. What do we wanna do here? Make pad that out, of course. And then we probably wanna make it a little bit, you know, make it b g grade hundred. So now we can have our text area text area. And inside of that text area, we're gonna we can have a handful of things. So let's, you know, make it class name equals, and then we'll say, like, maybe form, text area, make it full width. And I don't like all that, so let's just kinda keep going. We'll pad it out by two, and maybe give it a border around it. What else is text white. Yep. BG gray. Border is gonna be a little lighter. Resize none. Doesn't let the user resize and the height should be auto. If I save that all out, now we have a text area. Look at that. Hello. And then, let's pop into maybe a placeholder and just say enter your message here. So that feels really nice. Let's maybe cut this out. That feels really good. Let's add a button here really quickly, and then we're good to go. So finally, let's add a button. Our button, our button similar, we're gonna have a class name, and then we'll say, like, maybe we'll make it, let's see. Let's make it green. Just kinda BG green, maybe 600. These are all default styles. We'll make it kinda 700. Yeah. Bold it. Give it a little bit of padding. PG green. Oh, that did not complete. Yeah. That looks good. And it needs some content as well. Just something to say, like, maybe send, and boom. Now we have a button. So our messages, what they'll look like is maybe we put one in there just to start is pretty, pretty simple. Looks something like this. So we would have a dev I'm getting my notes up. Sorry. We have a dev and we would have, you know, a class name equals that. And then we would maybe, like, pad them out a little bit, give them a margin on the top and bottom so they kind of pad against each other. There'll be an iterator around this if you think about it, that would work. And then there'll be, you know, maybe rounded on the sides and rounded large, text white, auto background gray. Yeah. That seems reasonable. And then, we wanna put in there. You know, we'll put in our message so we can have our message here. Hi. And there's our message. And then we can have our sources will actually also go in there. And so our sources would go, like, kind of here if you say, like, sources would go below this. Sources would be the all of the things all the documents that come down. So we maybe have, like, a horizontal rule. We'll put it in a dev just to, like, kinda contain everything. And then we maybe have, like, a horizontal rule that has, yeah, that seems reasonable. And then the sources will go below that. So we'd say, like, dev. Wow. It's really gonna complete that whole thing for me. So sometimes it does actually not do a bad job. Of course, it completed too much. If here, It's missing one div. If you notice here, if I just see what it's completing, it created a div, then it created another div, which I don't think is necessary. We could, well, we can do that because it'll make it more it'll make it block. But we just need to close out one more dev. Cool. So we have our sources here, and we have kinda test PDF. And if we had a whole let's make those extra small. I think that'll look better. You know? And if we had a handful of them, it'll look kinda like this. And Wrong place. If we do here. Cool. That looks pretty good. So that's why that didn't work. And it doesn't need to be there anyway, although it can later, be there. So there's a nice little kinda output. We do probably want one more message. So, you know, if we look we have oops. If we look here we have this one message here, which is this could be like ID equals just so we can kind of see what it is, you know, human message. I'm going to delete this ID anyway, I just wanted to kind of label it for us, but if I if I look at this I can also dupe it and make a AI message and that AI message maybe want the background gray to be 900 or something like that. So we have boom boom looks really nice, clean front end. Boom, look at that. So if I hide all this, you can see the overall structure. We have our header, we have our footer, we have a flex that grows. We could push this down to the bottom if we wanted to. I actually kind of like it there although because you have to do some like VH stuff to pin it down or have another flex area. And not really the point of this tutorial is to sit here in monkey with TypeScript. So I think this is a pretty good start, you know. And if we had here, you know, AI message, here you can see, you know, we have two. We have a front end we have an AI message, and we have a human message. So now we could actually do some some programming. So we have our front end scaffolded out. We have, you know, these sources coming in just as you would expect. And then we have, you know, we have oops. We have our sources, so we have kind of two messages. We'll need a loop there, and we'll need an if statement that decides on the background color. We'll need to put the sources in, then we'll have to handle the input of everything from here. So first things first for me is just getting that input. And so React requires a decent amount of boilerplate, which is always a bummer. You can always use ChatGPT or Find or another coding helper to help you get this done. But for me, I like to you you know, I I can just kind of code this out. I've done enough on the front end. Although, I prefer the back end, and the front end's kind of nonlinear nature doesn't make it as good, you know, for these tutorial videos, but it's nice to see what's going on. So I'm just gonna add a on key up. I like the key up better than the key down because if you hold it, you can kind of rethink what you're doing, and then we just wanna say, like, handle key press, and that would handle, you know, the the key press stuff. And then on our on our value, we're going to take our input value. So this is this is really basic React boilerplate. And so when you have React, you have to store state inside of your functional components. And so we're going to have a helper method that handles a lot of behavior around the key presses, maybe adding a loading state, whatever we want, and then our value needs to be some sort of state. So in order to do that, we can just say use state, and our basic kind of input value is, of course, gonna just be an empty string. And then what comes out of our use state is two functions. And you can name them whatever you want, but you know, destructure it into an array here you get two functions and so what I want to call them is input value, which is the current input value and set input, input value, which is a function and these are super, super simple. If you're not familiar with React, this is not the right tutorial for you. And so now we need to do is define our handle key press and it's even suggesting us, here. So let's just take that. So on our key press, all this is doing is saying when you press enter, clear your input value. If I type here, if you notice, we're not doing anything. We it actually is not typing. And the reason I don't know if you can hear my keyboard, but it's not typing. And the reason that is is we now are handling the key up events here, but we're not setting that data. And so what you need to do is also when we take in our message So hold on. Let me pull up my notes. We'll take an on change method as well, and that'll handle we can handle the input value here. So here we're setting the input value to our event target, which is the the text area. And if we go here, now we're typing and the nice thing is actually what that's doing is it's updating our input and if I hit enter, you notice it cleared our input. So I actually really like being able to add more lines. So I say, you know, kind of and, the event is not the shift key. This will then allow us to say shift, shift, shift, enter, but then we can type and hit enter and it sends it off and we're good to go. So, perfect. So now we're handling our key press. Let's handle our button click, which should also kind of clear it. Or and so I want to say let's take the set input value and we'll move it into a new function and we'll say handle maybe call that like, handle send message, and this is gonna be a const, and this is gonna be a function, and our handle send message, I'd like to just take a string, and we'll say message string. And that feels really nice. That handles send message, so if we do this now and we just console log out our message let me see here. You notice nothing really happens, no errors, no anything like that. It's because we're not calling this handle send message. So what we can do here is move this up to here, and then we can call handle send message from our so we'd say event dot value, and we have that actually down here. You can see target value e dot target e dot target dot value. And that's a oh, silly me. Nope. We do not wanna send our target value. We wanna send our input value. Silly me. That'll send our input value into handle send message and then same here. And here, we also want to on our button have an on click, and we'll say, you know, send message, and we'll handle that too. So now if we type in here and we click send, it sends it up. And if you notice, we logged out our message here. And same if I go here and I type and I hit enter, not shift enter, and I hit enter, we get our logs over here. Can I make this bigger? Oh, that's gonna be really nice hopefully for everybody, and we'll give ourselves the full console here. Oops. So you can just see what's coming in. So if you notice, I was able to log, you know, log with enter, and I just hit enter here. Boom. Log with enter, and I say, you know, log with button and I hit send and we're good. So now we have kind of the scaffolding, if you will, to handle sending our message up to a server. So let's get some work done. This is my favorite part of this is we pop into this and we need to send it up to Lang serve. If you remember, Lang serve streaming endpoint takes a, HTTP post to whatever your, whatever your path is. So in this case, we said rag. So whatever our path is slash stream and that HTTP post needs to be in the format of our input. You can actually see that inside of the docs that it gives you. So you can see here, we need a format of like input with question, and then we return out, you know, something. And then these are optional, the quarks and the config. If we were doing runtime configuration of our pipeline or anything like that, that's where those would go. But we are not, and we won't in this tutorial. So what I want to do here is I want to just say, you know, await batch event source, and then what this is gonna do look at that. I'm actually getting pretty decent completion, although the and then this needs to be an async function. Dip dip dip dip dip dip dip dip dip dip dip dip dip dip dip dip dip dip dip dip dip dip. Duh. Like Python in my head. Cool. There we go. So we're gonna post up to local host 8,000 and we will post to rag slash stream. It will we will need to move this part of our, this part of our, component. Thank you. Oh, my gosh. Brain fart. This part of our component into environment config so that we can give a different thing in production. And then we need to post some stuff up. So to do that, we just say method post and then we're gonna, you know, put in our headers. We'll give you some JSON and then we need to do our body. And if you notice, I don't need this configurable here, but what I do want to pass in is our question and our message, and that will send everything we need back up to our server. We don't handle any output yet, but that's okay. So now if I go here and I say hello and I send send, look at that. It sent something to our server, but we're getting a CORS error. So when you get a CORS error, it's really easy to fix. What you want to do is you want to hop into your server and you're just going to add some middleware. So this was the error that I said we would need to handle and I would error drive. So I wanted to show you what that cores error looks like. I'll show you one more time. Hello. If you notice here, it says, you know, been blocked by cores. So that's telling you that there's a cross origin request. Your back end is not allowing it, from this specific or particular front end and so we need to handle it. So after we create our app in fast with fast API, we want to add middleware and that middleware, we just want to allow look at that. Our core is middleware and then we'll just allow kind of everything else in. And this import often imports the wrong thing for me. It is importing, if you notice, starlet middleware. And, actually, what I wanna do is import a fast API because I don't have that, dependency. And so now, that should have reloaded, and I say, hello. Here. Let me save this. I don't think I saved. And I say, hello. Nope. Local host 3,000. Local host 3,000. Let's restart our server. 12. Hop over here. Restart our server. Get that shoved in there and say hello now. Just see if that does it for us. Look at that. So note, we did get our post to our rag slash stream. No output, of course, because, well, we're not doing anything with it, but we're no longer getting, we're no longer getting any errors. So, actually, I'm going to put this at the bottom. I think it'll be a little easier for us to kinda handle the amount of screen space that we have. And we'll hide this for now, and we'll hop back into our app. So now in this, inside of our inside of our fetch event source, we wanna start grabbing our event data and then manage it. So Copilot continues to make some phenomenal suggestions for me. And so we're going to say if our event comes back with data and I actually what I want to do is before we kind of jump all the way to that, I'm going to just say console log console log the event. And if I say hello here, you'll notice we get a whole bunch of stuff coming back. So we get our run ID, some metadata. If you notice, this event type is metadata. And then we have, you know, an event here. We have, an event with the type of data, and then we have some data. That data has docs. This is a string, so we'll have to deal with that. And then we have, that answer key. So if you remember in our rag pipeline, we said we wanted to put out docs and answers as our two top level keys. And then inside of that, we have, you know, content, plus, like, some additional orgs, make sure it's an AI message, and then you can see whether or not it's an example. And, that works well. If you wanted to just get your messages here as content, what you can do instead is use the string output parser inside of the pipeline, but I actually like having a little bit more structure inside of what's sent down to the client. So now since we know what we're getting and we're getting, you know, an event with the type of data, we're going to say we have this handle receive message, and we're going to handle anything that we get with the event type of data. I'm going to generate that. It's a string. It feels really nice, and we're going to handle our receive message. So there are a few things that we're going to need to do in here. The first thing is, of course, we're passing this data in, but if you notice this data is a string, so we're going to have to JSON parse it, parse our data and I don't like the completion there. And then we'll grab this out and we'll say parsed data. And I always wrap this in a try accept if you want or you can kinda leave it and get the errors on the front end. If you wrap it in try accept, you could, like, maybe push that error off to an error handler, or, you know, something that alerts you, whatever you need to do so you can see why it's not sending the right thing. But now if we look at our parsed data and we clear out our console and we say hello, we're gonna have, you know, our array of documents and then a whole bunch of chunks of answers. Hello with an exclamation point, you know, each tokens, it's nice to see you or whatever it's saying, and then our documents. And our documents have, you know, page content. And then inside of that, they have a metadata key. And then inside of that metadata, they have a source, which is great and that's what's coming from our vector store. So now that we have that, we just kind of have to parse all that out. We have to use our parsed data and generate our messages and our source. So I would say first like if our parse data, parsed whoops. Yeah. I see. If parsed data dot, and if we look here, let's handle the messages first. If parsed data dot answer, answer, then we wanna do something. So we wanna maybe, like, create a message, and then, we wanna say something like if, parse data .docs, Or what was that name of this one? Parsed data .docs. Yeah. That seems really reasonable. And then we wanna do something with the documents, like append that to a message. So I do think there's probably a nice type we could use here because we're starting to structure out, like, a message, which is what this is gonna be. And we're gonna have, like, maybe it's a user message or an AI message, and then it's gonna have message content, which is this high or this AI message, and then it's gonna have some sources. So let's let's start structuring that. So we'll give ourselves an interface and we'll call it a message. And that message is going to say, oh, look at that. We don't need this is stream, but we can take everything else. So we have our message, we have whether or not this message is a user, and then we have, you know, our sources, which is an array of strings. And that feels really clean, actually, really, really clean. So what I wanna do before we start handling the return to messages is if you notice, we're not actually handling when I send this, although it's posting up to the server, we're not putting it into like the display. And you would expect, you know, like in a standard chat application, you hit enter and it shows up here as your user message, and then the AI message streams out just afterwards. And that user message probably doesn't have any sources because it's coming from the user. So what I wanna do is say on our handle send message, or sorry, in our, yeah, in our handle send message, Maybe we say something along the lines of, yeah, let's do this. So on our handle key press ups and we are handle send message and our handle send message, which is okay. Maybe we want to do something a little bit more clean. And so like we have handle key press, which sends the message and we have handle send message. And then we kind of just set our input value here. And so maybe what I want to do is say handle send message, maybe create one new and we'll say call this maybe like handle user message, which is kind of the same as handle send message and the user message is always gonna send. So it's actually we could just put it right in here. So as we set our input value to this, we also want to just kind of working my way through it and how I would think about it. I wanna say, like, maybe set a message, set messages, and it's completing that for me. Looks pretty good. So this is another state. Our messages down here need to be kind of iterative and be part of our state. So what I want to do here is say const messages equals, you know, messages and we have set message and then I typed it or Copilot did that for me. But this is an array of messages is what our state is and it initializes as empty. If you notice that did just fine here. And then what we're doing is we're appending our previous we're taking all of our previous messages. We're spotting out our previous messages and appending our, new message, and we're making sure that that is a user message. So when I save this, that will come in. It's not gonna do anything yet because we don't have any iteration down here. So I'm gonna leave these two kind of stubbed messages just for us to start, and I'm gonna say, you know, messages dot map, And now we have our messages, and we can map them out. And let's, just move this. Oh, I see what it did. It just expanded those, which feels a little awkward. So, give me a second to fix all that. So if we go messages here, we say messages dot map, and we have kinda everything aside. We can do is put that around these two things, and we're not gonna have two. It's red right now because there's two things inside of there. And so we have our human message and our AI message. And what I wanna do is we have our message and we have an index because instead let's get rid of this key and we'll say key equals index. So that'll let it react, iterate, and be efficient about how it spins up. And then in our classes, we want to differentiate the two. So let's turn this into a template. Let's turn this into a template, which is surprising that it won't do that. And I don't know why it's angry about that. Last name is gonna be this. Maybe oh, because it needs to be in this stuff. We turn this into a template, and then we want to say, you know, in our template, if we're a user, maybe like is user, then we return that one. Otherwise, let's do let's do BGDashGrayDash900. And this is not just is user. This is user comes from the message. And what did I break here? We have our index. We have a class name. Oops. Class name or a template is user here. I delete this. Does it compile? What broke? Backup. It's weird. Oh, because it has two in there, I think. Yeah. See and if I read my errors rather than just kind of trying to solve this without looking, if you notice it's saying, did you wanna do a JSX module fragment, which is like wrapping those two things? And so now if I just close this out and I delete or comment out that whole section, which isn't gonna work that well. So if I go here and I close out, let's go to our AI message and delete our whole AI message section here. What is going on here? We have that one and that one next to each other. Our map is in the wrong place for our yeah. This should be here, I think. I don't know how that happened. We'll look at this once we get down to one. So we have let's delete this AI message section here and then we have this whole AI message which has some sources. So here let's see how we did this. We have our messages. We're mapping those out. We have our div with everything inside of it. This is one of the reasons I don't like always doing the scaffolding. We have that div. Closes there. That's what I would expect. Oh, just missing a parenthesis. Boom. Classic. Now if I say hello, I hit enter. We get hi. And the reason for that, if you kind of think about it, is we didn't put our message in here. So if I go here and I say message dot message, not is user message, we get our hello. And we're still streaming out all of our output as you would expect, and that feels really nice. So now let's handle creating our AI message. And, actually, while we're here, let's say let's wrap this entire section here. Message dot sources or else a dot message dot is user and do that. And then we go down. So if we look here and create a little paren here, put that down, bring that up, create a little paren here, and that should give us not displaying our sources if it's not a user message. Cool. That feels really nice. We have our hello. We're sending everything up. So now let's hop back into this. So now we need to handle our answer and our parsed data or our answer on our documents, and we want to fill out our AI message. So for this, we actually are getting partial messages back. And so we can't just do this set message and like shove in a whole message like we did before. We have to do a little bit more work. And so I like doing this kind of create a method called set partial message. Just makes it a little cleaner for me to understand what's going on. So, set set partial message, and we're gonna take a chunk and a string of source or array of sources. And it can be either of those two things, and that feels really easy. And then here, I wanna say in my, beginning here, I wanna say set partial message, and we're just gonna pass in dot content. And that's just gonna be the content. If you remember here in our thing, we have content my so that's gonna send that in. And then in our docs, we're gonna just say set partial message, and we don't have any content. So we're actually gonna just say, well, I don't know how it's doing that, but we will pass in a map of our sources. So if you remember from our docs, where is a doc here? We have an array of documents, one, two, three, four, and each one of those has a source. So all I'm doing is I'm pulling that source out here and only passing that in. And now in my partial message, I can do something really clean, which is I can say set messages, and then we get our previous messages and we yield out, into our function. And then here, we'll need to return something. So I actually wanna get my this is pretty good. So what this is saying is, you know, get our last message. If our last message so, like, if we have messages or our last message is a stream and we actually don't need that for this implementation, then we wanna attend append to it. But we can say if our last message is a user message, then we wanna create a new one. Otherwise, we need to create a new message that is not a user so that we can start appending to it. So we don't have this is stream, but if if the last message is a user, is not a user, so if we don't have any messages, or our last message is a user is not a user, sorry, is not a user, then we are going to slice off the last message. Right? So we're gonna take everything that's in our messages minus the last one, and then we're going to append to it a new message right here. That's what's happening here. That is a not a user message with our current last message. That's what we pulled from here, plus the chunk. And, actually, this can just go in here and const. And, we need that, actually. There. Because we need to know if it's a user. So that'll work outside. And so we are taking what was kind of currently in the stream plus whatever came in in our current chunk here. You remember that was like these one kind of words or set of tokens. And then, we're also appending sources if new sources come in at any time. And that's just through restructuring that into an array or just creating an array of sources. Here, if instead we are already not a user message, or we are our last message is a user message, we actually don't need this as an if else because it it's a it's guarded. If you notice, we already returned here. We returned here, so we don't need that. We just take our previous messages. We put in one that isn't a user message, and, we add in our sources, as you would expect. And so now if I say, what is the case about and I hit enter, I get some sources and the document, and we stream out the output. That comes out really nicely. Up, up, up, up, up. So last and not least, let's make these things here, the actual sources. So one of the things that's coming here is our sources are like the full path, and I really just need the final file. And so I'm gonna build that link down here. Sorry, not down here. I'm gonna just build it in the JSX. There's definitely a cleaner way to do that, but for now, I think this is a really nice easy way to do it, and I probably have it hidden. So here, if you notice, we have our horizontal rule, and then we have kind of all of our divs of sources. So let's do this. So I'll say message dot sources. So if we have sources on our message and everything, then but come on. If we have message sources on our message, Yeah. And then we'll get rid of all these. Let's just, like, make it only one of them for now. Work with this here is what we want to iterate over. Right? So we have kind of a wrapping div of our sources. I actually don't know if this is necessary, but what does that do? Nothing really? Okay, cool. This is not a necessary div. Just kind of getting dev crazy. So here, we're gonna do, you know, message dot sources map. We map those out, and that's gonna go just below this div here. We'll close out our map. And so now notice we have four. They just came in for me right there, and so that's because we have four documents getting returned. So it's really nice to see. And then we can say here, we wanna say our message dot source or not source. Sorry. We just wanna say source. If we look here, that's like my full path. So, dot split on our thing and then say dot pop. That should just give the last, part of the path, and we can do that again up here, and it's probably smart. Source could be undefined. So we just need to go here and go or this. And let's pop this up into a little helper here. Not like that. We'll pop that up into a little helper. We'll put it in here, and we'll just call it format source. And then we can do that down here too. And those come in just great. We have our links. If you look, I can't you can see kind of at the very bottom, it's really small, but right below the send button, you can see the link in Chrome. It's like shows up right here. It's linking to local host, 5,000 and everything feels pretty good. So now what do we do? That's a great question. So I really like being able to serve, static we can serve the static files straight out of our server. So it's just gonna be the same as our back end URL, which is nice. And, let me try to remember how to do that. Look at my notes really quickly. We're gonna take our static files and we'll mount that in just as, like, anywhere. We kinda want it to be the first path. I like it being first, but it doesn't have to do. You can say app dot mount, and then we're gonna add a slash rag slash static. So this will catch that static path before here. And then, we can say static files. Actually, that's perfect. We're gonna take it from our source docs. And again, actually, that can come from Starlet. That's fine. And that will give us everything we need to download these. If I go here, we look at our path one more time, it goes to static epic. So we want to link to rather than just static, we want to link to rag so it's coming from the right place. Rag slash static. And so now if I go here and I click download, oh, I probably need to restart my server, and, oh, of course, our port is wrong. So now if I come here and the port looks right and everything looks good, it's loading and loading still. If I do a different one maybe if I restart my server. Look at that. We have an error. What is the name of our source documents directory? And it's up two paths is actually what's happening. If you notice, we are in app. No, it's not. We're in app. So, we're going to go, you know, we're app server and we just want to go up one and then source docs. Let's just try restarting and see if it can grab it now. Source docs directory does not exist. See if it's just dot slash. That would be weird to me, though. Nope. That is it. Because we're starting that from the start, and now we get our document links in, we get our document name. You could format these however you want. You just play with your format docs method, and it feels really nice. And there you go. We're back to a working, chat with sources and everything. So I do wanna deploy this. What time is it? How long have we been going? We're at, 09:26. So, actually, what I'm gonna do, we've been going for almost an hour, is I'm gonna make a commit, and then I'll upload another video with this deployed where on how we deploy this to DigitalOcean as well as, Lang serve. But I think these kind of like one hour chunks are really nice. I'll try to get this next one done this week. In the future, what I'm thinking is we do, we do one every Tuesday. So we try and release a new tutorial every Tuesday and give everybody opportunity to give feedback on the tutorials, ask questions. I'm available in the LangServe Discord. I'm also always there, you know, to help. Let's go over what we did really quickly just so you can see and then we can move on. So we really started out a really clean application. So this clean application is if you remember, we generated a front end using create react app. We added TypeScript to the application and then, sorry, we added Tailwind to the application and we do it in TypeScript. We scaffolded out a front end using React and Tailwind, and then we took from Langserve using the documentation here knowing what we need to send and take. We took from Langserve that information, and we display it on the front end in a nice clean chat. So let's get this committed, and we'll push it up after the video is over. So if we look here, we removed our string parallel. We removed our string output parser and worked inside of our rag chain to create a chain that returns both an answer and documents. We mounted, we handled course or yeah. So cross origin, and we mounted our static files so that they could be served straight out of lang serve. We added batch event source and a handful of dependencies for the front end. And then we, of course, created an entire, you know, front end app. And then we made sure we added Tailwind in the correct places, and that gives us and configure Tailwind to work, and that gives us a full working front end. Create working front end chat or lang serve rag. And let's authorize that and, actually, I'm gonna, of course, push this up over some stuff that's already there. Don't force push unless you absolutely need to, but I know what's there. I'm gonna force push this up over what's already there so we have a clean, output for you to or clean GitHub repo for you to look at. So thanks for watching. You know, make sure you click like, click subscribe, make comments. I'm available, like I said, in the Langstrove Discord. I'm on axe. I want to help you guys and gals dive into this stuff, see how easy it is to start hacking with Langchain. So thank you all so much for your time and your energy and, ask questions. Seriously, it's, like, super motivating for me to help you all. So good luck and talk to you later.